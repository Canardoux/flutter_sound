import { addIcons } from 'ionicons';
import { arrowBackSharp, caretBackSharp, chevronBack, chevronForward, close, closeCircle, closeSharp, menuOutline, menuSharp, reorderTwoSharp, reorderThreeOutline, searchOutline, searchSharp } from 'ionicons/icons';
import { defineComponent, ref, getCurrentInstance, inject, h, computed, provide, shallowRef, watch, onUnmounted, Teleport } from 'vue';
import { LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, setupConfig, isPlatform, actionSheetController, alertController, loadingController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
export { IonicSafeString, actionSheetController, alertController, createAnimation, createGesture, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, loadingController, mdTransitionAnimation, menuController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
import { applyPolyfills, defineCustomElements } from '@ionic/core/loader';
import { routeLocationKey, useRoute, matchedRouteKey } from 'vue-router';

const UPDATE_VALUE_EVENT = 'update:modelValue';
const MODEL_VALUE = 'modelValue';
const ROUTER_LINK_VALUE = 'routerLink';
const NAV_MANAGER = 'navManager';
const ROUTER_PROP_REFIX = 'router';
const getComponentClasses = (classes) => {
    var _a;
    return ((_a = classes) === null || _a === void 0 ? void 0 : _a.split(' ')) || [];
};
const getElementClasses = (ref, componentClasses, defaultClasses = []) => {
    var _a;
    return [...Array.from(((_a = ref.value) === null || _a === void 0 ? void 0 : _a.classList) || []), ...defaultClasses]
        .filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);
};
/**
* Create a callback to define a Vue component wrapper around a Web Component.
*
* @prop name - The component tag name (i.e. `ion-button`)
* @prop componentProps - An array of properties on the
* component. These usually match up with the @Prop definitions
* in each component's TSX file.
* @prop componentOptions - An object that defines additional
* options for the component such as router or v-model
* integrations.
*/
const defineContainer = (name, componentProps = [], componentOptions = {}) => {
    const { modelProp, modelUpdateEvent, externalModelUpdateEvent } = componentOptions;
    /**
    * Create a Vue component wrapper around a Web Component.
    * Note: The `props` here are not all properties on a component.
    * They refer to whatever properties are set on an instance of a component.
    */
    const Container = defineComponent((props, { attrs, slots, emit }) => {
        var _a;
        let modelPropValue = props[modelProp];
        const containerRef = ref();
        const classes = new Set(getComponentClasses(attrs.class));
        const onVnodeBeforeMount = (vnode) => {
            // Add a listener to tell Vue to update the v-model
            if (vnode.el) {
                const eventsNames = Array.isArray(modelUpdateEvent) ? modelUpdateEvent : [modelUpdateEvent];
                eventsNames.forEach((eventName) => {
                    vnode.el.addEventListener(eventName.toLowerCase(), (e) => {
                        modelPropValue = (e === null || e === void 0 ? void 0 : e.target)[modelProp];
                        emit(UPDATE_VALUE_EVENT, modelPropValue);
                        /**
                         * We need to emit the change event here
                         * rather than on the web component to ensure
                         * that any v-model bindings have been updated.
                         * Otherwise, the developer will listen on the
                         * native web component, but the v-model will
                         * not have been updated yet.
                         */
                        emit(externalModelUpdateEvent, e);
                    });
                });
            }
        };
        const currentInstance = getCurrentInstance();
        const hasRouter = (_a = currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.appContext) === null || _a === void 0 ? void 0 : _a.provides[NAV_MANAGER];
        const navManager = hasRouter ? inject(NAV_MANAGER) : undefined;
        const handleRouterLink = (ev) => {
            const { routerLink } = props;
            if (!routerLink)
                return;
            const routerProps = Object.keys(props).filter(p => p.startsWith(ROUTER_PROP_REFIX));
            if (navManager !== undefined) {
                let navigationPayload = { event: ev };
                routerProps.forEach(prop => {
                    navigationPayload[prop] = props[prop];
                });
                navManager.navigate(navigationPayload);
            }
            else {
                console.warn('Tried to navigate, but no router was found. Make sure you have mounted Vue Router.');
            }
        };
        return () => {
            modelPropValue = props[modelProp];
            getComponentClasses(attrs.class).forEach(value => {
                classes.add(value);
            });
            const oldClick = props.onClick;
            const handleClick = (ev) => {
                if (oldClick !== undefined) {
                    oldClick(ev);
                }
                if (!ev.defaultPrevented) {
                    handleRouterLink(ev);
                }
            };
            let propsToAdd = Object.assign(Object.assign({}, props), { ref: containerRef, class: getElementClasses(containerRef, classes), onClick: handleClick, onVnodeBeforeMount: (modelUpdateEvent && externalModelUpdateEvent) ? onVnodeBeforeMount : undefined });
            if (modelProp) {
                /**
                 * Starting in Vue 3.1.0, all properties are
                 * added as keys to the props object, even if
                 * they are not being used. In order to correctly
                 * account for both value props and v-model props,
                 * we need to check if the key exists for Vue <3.1.0
                 * and then check if it is not undefined for Vue >= 3.1.0.
                 */
                propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: props.hasOwnProperty(MODEL_VALUE) && props[MODEL_VALUE] !== undefined ? props.modelValue : modelPropValue });
            }
            return h(name, propsToAdd, slots.default && slots.default());
        };
    });
    Container.displayName = name;
    Container.props = [...componentProps, ROUTER_LINK_VALUE];
    if (modelProp) {
        Container.props.push(MODEL_VALUE);
        Container.emits = [UPDATE_VALUE_EVENT, externalModelUpdateEvent];
    }
    return Container;
};

/* eslint-disable */
const IonAvatar = /*@__PURE__*/ defineContainer('ion-avatar');
const IonBackdrop = /*@__PURE__*/ defineContainer('ion-backdrop', [
    'visible',
    'tappable',
    'stopPropagation',
    'ionBackdropTap'
]);
const IonBadge = /*@__PURE__*/ defineContainer('ion-badge', [
    'color'
]);
const IonButton = /*@__PURE__*/ defineContainer('ion-button', [
    'color',
    'buttonType',
    'disabled',
    'expand',
    'fill',
    'routerDirection',
    'routerAnimation',
    'download',
    'href',
    'rel',
    'shape',
    'size',
    'strong',
    'target',
    'type',
    'ionFocus',
    'ionBlur'
]);
const IonButtons = /*@__PURE__*/ defineContainer('ion-buttons', [
    'collapse'
]);
const IonCard = /*@__PURE__*/ defineContainer('ion-card', [
    'color',
    'button',
    'type',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target'
]);
const IonCardContent = /*@__PURE__*/ defineContainer('ion-card-content');
const IonCardHeader = /*@__PURE__*/ defineContainer('ion-card-header', [
    'color',
    'translucent'
]);
const IonCardSubtitle = /*@__PURE__*/ defineContainer('ion-card-subtitle', [
    'color'
]);
const IonCardTitle = /*@__PURE__*/ defineContainer('ion-card-title', [
    'color'
]);
const IonCheckbox = /*@__PURE__*/ defineContainer('ion-checkbox', [
    'color',
    'name',
    'checked',
    'indeterminate',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonChip = /*@__PURE__*/ defineContainer('ion-chip', [
    'color',
    'outline',
    'disabled'
]);
const IonCol = /*@__PURE__*/ defineContainer('ion-col', [
    'offset',
    'offsetXs',
    'offsetSm',
    'offsetMd',
    'offsetLg',
    'offsetXl',
    'pull',
    'pullXs',
    'pullSm',
    'pullMd',
    'pullLg',
    'pullXl',
    'push',
    'pushXs',
    'pushSm',
    'pushMd',
    'pushLg',
    'pushXl',
    'size',
    'sizeXs',
    'sizeSm',
    'sizeMd',
    'sizeLg',
    'sizeXl'
]);
const IonContent = /*@__PURE__*/ defineContainer('ion-content', [
    'color',
    'fullscreen',
    'forceOverscroll',
    'scrollX',
    'scrollY',
    'scrollEvents',
    'ionScrollStart',
    'ionScroll',
    'ionScrollEnd'
]);
const IonDatetime = /*@__PURE__*/ defineContainer('ion-datetime', [
    'name',
    'disabled',
    'readonly',
    'min',
    'max',
    'displayFormat',
    'displayTimezone',
    'pickerFormat',
    'cancelText',
    'doneText',
    'yearValues',
    'monthValues',
    'dayValues',
    'hourValues',
    'minuteValues',
    'monthNames',
    'monthShortNames',
    'dayNames',
    'dayShortNames',
    'pickerOptions',
    'placeholder',
    'value',
    'ionCancel',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonFab = /*@__PURE__*/ defineContainer('ion-fab', [
    'horizontal',
    'vertical',
    'edge',
    'activated'
]);
const IonFabButton = /*@__PURE__*/ defineContainer('ion-fab-button', [
    'color',
    'activated',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target',
    'show',
    'translucent',
    'type',
    'size',
    'closeIcon',
    'ionFocus',
    'ionBlur'
]);
const IonFabList = /*@__PURE__*/ defineContainer('ion-fab-list', [
    'activated',
    'side'
]);
const IonFooter = /*@__PURE__*/ defineContainer('ion-footer', [
    'translucent'
]);
const IonGrid = /*@__PURE__*/ defineContainer('ion-grid', [
    'fixed'
]);
const IonHeader = /*@__PURE__*/ defineContainer('ion-header', [
    'collapse',
    'translucent'
]);
const IonImg = /*@__PURE__*/ defineContainer('ion-img', [
    'alt',
    'src',
    'ionImgWillLoad',
    'ionImgDidLoad',
    'ionError'
]);
const IonInfiniteScroll = /*@__PURE__*/ defineContainer('ion-infinite-scroll', [
    'threshold',
    'disabled',
    'position',
    'ionInfinite'
]);
const IonInfiniteScrollContent = /*@__PURE__*/ defineContainer('ion-infinite-scroll-content', [
    'loadingSpinner',
    'loadingText'
]);
const IonInput = /*@__PURE__*/ defineContainer('ion-input', [
    'fireFocusEvents',
    'color',
    'accept',
    'autocapitalize',
    'autocomplete',
    'autocorrect',
    'autofocus',
    'clearInput',
    'clearOnEdit',
    'debounce',
    'disabled',
    'enterkeyhint',
    'inputmode',
    'max',
    'maxlength',
    'min',
    'minlength',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'step',
    'size',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonItem = /*@__PURE__*/ defineContainer('ion-item', [
    'color',
    'button',
    'detail',
    'detailIcon',
    'disabled',
    'download',
    'href',
    'rel',
    'lines',
    'routerAnimation',
    'routerDirection',
    'target',
    'type'
]);
const IonItemDivider = /*@__PURE__*/ defineContainer('ion-item-divider', [
    'color',
    'sticky'
]);
const IonItemGroup = /*@__PURE__*/ defineContainer('ion-item-group');
const IonItemOption = /*@__PURE__*/ defineContainer('ion-item-option', [
    'color',
    'disabled',
    'download',
    'expandable',
    'href',
    'rel',
    'target',
    'type'
]);
const IonItemOptions = /*@__PURE__*/ defineContainer('ion-item-options', [
    'side',
    'ionSwipe'
]);
const IonItemSliding = /*@__PURE__*/ defineContainer('ion-item-sliding', [
    'disabled',
    'ionDrag'
]);
const IonLabel = /*@__PURE__*/ defineContainer('ion-label', [
    'color',
    'position',
    'ionColor',
    'ionStyle'
]);
const IonList = /*@__PURE__*/ defineContainer('ion-list', [
    'lines',
    'inset'
]);
const IonListHeader = /*@__PURE__*/ defineContainer('ion-list-header', [
    'color',
    'lines'
]);
const IonMenu = /*@__PURE__*/ defineContainer('ion-menu', [
    'contentId',
    'menuId',
    'type',
    'disabled',
    'side',
    'swipeGesture',
    'maxEdgeStart',
    'ionWillOpen',
    'ionWillClose',
    'ionDidOpen',
    'ionDidClose',
    'ionMenuChange'
]);
const IonMenuButton = /*@__PURE__*/ defineContainer('ion-menu-button', [
    'color',
    'disabled',
    'menu',
    'autoHide',
    'type'
]);
const IonMenuToggle = /*@__PURE__*/ defineContainer('ion-menu-toggle', [
    'menu',
    'autoHide'
]);
const IonNavLink = /*@__PURE__*/ defineContainer('ion-nav-link', [
    'component',
    'componentProps',
    'routerDirection',
    'routerAnimation'
]);
const IonNote = /*@__PURE__*/ defineContainer('ion-note', [
    'color'
]);
const IonProgressBar = /*@__PURE__*/ defineContainer('ion-progress-bar', [
    'type',
    'reversed',
    'value',
    'buffer',
    'color'
]);
const IonRadio = /*@__PURE__*/ defineContainer('ion-radio', [
    'color',
    'name',
    'disabled',
    'value',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonRadioGroup = /*@__PURE__*/ defineContainer('ion-radio-group', [
    'allowEmptySelection',
    'name',
    'value',
    'ionChange'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonRange = /*@__PURE__*/ defineContainer('ion-range', [
    'color',
    'debounce',
    'name',
    'dualKnobs',
    'min',
    'max',
    'pin',
    'snaps',
    'step',
    'ticks',
    'disabled',
    'value',
    'ionChange',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonRefresher = /*@__PURE__*/ defineContainer('ion-refresher', [
    'pullMin',
    'pullMax',
    'closeDuration',
    'snapbackDuration',
    'pullFactor',
    'disabled',
    'ionRefresh',
    'ionPull',
    'ionStart'
]);
const IonRefresherContent = /*@__PURE__*/ defineContainer('ion-refresher-content', [
    'pullingIcon',
    'pullingText',
    'refreshingSpinner',
    'refreshingText'
]);
const IonReorder = /*@__PURE__*/ defineContainer('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ defineContainer('ion-reorder-group', [
    'disabled',
    'ionItemReorder'
]);
const IonRippleEffect = /*@__PURE__*/ defineContainer('ion-ripple-effect', [
    'type'
]);
const IonRow = /*@__PURE__*/ defineContainer('ion-row');
const IonSearchbar = /*@__PURE__*/ defineContainer('ion-searchbar', [
    'color',
    'animated',
    'autocomplete',
    'autocorrect',
    'cancelButtonIcon',
    'cancelButtonText',
    'clearIcon',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'placeholder',
    'searchIcon',
    'showCancelButton',
    'showClearButton',
    'spellcheck',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionCancel',
    'ionClear',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonSegment = /*@__PURE__*/ defineContainer('ion-segment', [
    'color',
    'disabled',
    'scrollable',
    'swipeGesture',
    'value',
    'ionChange',
    'ionSelect',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonSegmentButton = /*@__PURE__*/ defineContainer('ion-segment-button', [
    'disabled',
    'layout',
    'type',
    'value'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonSelect = /*@__PURE__*/ defineContainer('ion-select', [
    'disabled',
    'cancelText',
    'okText',
    'placeholder',
    'name',
    'selectedText',
    'multiple',
    'interface',
    'interfaceOptions',
    'compareWith',
    'value',
    'ionChange',
    'ionCancel',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonSelectOption = /*@__PURE__*/ defineContainer('ion-select-option', [
    'disabled',
    'value'
]);
const IonSkeletonText = /*@__PURE__*/ defineContainer('ion-skeleton-text', [
    'animated'
]);
const IonSlide = /*@__PURE__*/ defineContainer('ion-slide');
const IonSlides = /*@__PURE__*/ defineContainer('ion-slides', [
    'options',
    'pager',
    'scrollbar',
    'ionSlidesDidLoad',
    'ionSlideTap',
    'ionSlideDoubleTap',
    'ionSlideWillChange',
    'ionSlideDidChange',
    'ionSlideNextStart',
    'ionSlidePrevStart',
    'ionSlideNextEnd',
    'ionSlidePrevEnd',
    'ionSlideTransitionStart',
    'ionSlideTransitionEnd',
    'ionSlideDrag',
    'ionSlideReachStart',
    'ionSlideReachEnd',
    'ionSlideTouchStart',
    'ionSlideTouchEnd'
]);
const IonSpinner = /*@__PURE__*/ defineContainer('ion-spinner', [
    'color',
    'duration',
    'name',
    'paused'
]);
const IonSplitPane = /*@__PURE__*/ defineContainer('ion-split-pane', [
    'contentId',
    'disabled',
    'when',
    'ionSplitPaneVisible'
]);
const IonText = /*@__PURE__*/ defineContainer('ion-text', [
    'color'
]);
const IonTextarea = /*@__PURE__*/ defineContainer('ion-textarea', [
    'fireFocusEvents',
    'color',
    'autocapitalize',
    'autofocus',
    'clearOnEdit',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'maxlength',
    'minlength',
    'name',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'cols',
    'rows',
    'wrap',
    'autoGrow',
    'value',
    'ionChange',
    'ionInput',
    'ionStyle',
    'ionBlur',
    'ionFocus'
], {
    "modelProp": "value",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonThumbnail = /*@__PURE__*/ defineContainer('ion-thumbnail');
const IonTitle = /*@__PURE__*/ defineContainer('ion-title', [
    'color',
    'size',
    'ionStyle'
]);
const IonToggle = /*@__PURE__*/ defineContainer('ion-toggle', [
    'color',
    'name',
    'checked',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": [
        "v-ionChange",
        "v-ion-change"
    ],
    "externalModelUpdateEvent": "ionChange"
});
const IonToolbar = /*@__PURE__*/ defineContainer('ion-toolbar', [
    'color'
]);
const IonVirtualScroll = /*@__PURE__*/ defineContainer('ion-virtual-scroll', [
    'approxItemHeight',
    'approxHeaderHeight',
    'approxFooterHeight',
    'headerFn',
    'footerFn',
    'items',
    'itemHeight',
    'headerHeight',
    'footerHeight',
    'renderItem',
    'renderHeader',
    'renderFooter',
    'nodeRender',
    'domRender'
]);

var LifecycleHooks;
(function (LifecycleHooks) {
    LifecycleHooks["WillEnter"] = "onIonViewWillEnter";
    LifecycleHooks["DidEnter"] = "onIonViewDidEnter";
    LifecycleHooks["WillLeave"] = "onIonViewWillLeave";
    LifecycleHooks["DidLeave"] = "onIonViewDidLeave";
})(LifecycleHooks || (LifecycleHooks = {}));
const hookNames = {
    [LIFECYCLE_WILL_ENTER]: LifecycleHooks.WillEnter,
    [LIFECYCLE_DID_ENTER]: LifecycleHooks.DidEnter,
    [LIFECYCLE_WILL_LEAVE]: LifecycleHooks.WillLeave,
    [LIFECYCLE_DID_LEAVE]: LifecycleHooks.DidLeave
};
const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return (id).toString();
};
// TODO types
const fireLifecycle = (vueComponent, vueInstance, lifecycle) => {
    if (vueComponent === null || vueComponent === void 0 ? void 0 : vueComponent[lifecycle]) {
        vueComponent[lifecycle].bind(vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value)();
    }
    const instance = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value;
    if (instance === null || instance === void 0 ? void 0 : instance[lifecycle]) {
        instance[lifecycle]();
    }
    /**
     * Fire any Composition API
     * Ionic Lifecycle hooks
     */
    if (instance) {
        const hook = hookNames[lifecycle];
        const hooks = instance[hook];
        if (hooks) {
            hooks.forEach((hook) => hook());
        }
    }
};
const getConfig = () => {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return Ionic.config;
        }
    }
    return null;
};
const needsKebabCase = (version) => !['3.0.0', '3.0.1', '3.0.2', '3.0.3', '3.0.4', '3.0.5'].includes(version);

/**
* We need to make sure that the web component fires an event
* that will not conflict with the user's @ionChange binding,
* otherwise the binding's callback will fire before any
* v-model values have been updated.
*/
const toLowerCase = (eventName) => eventName === 'ionChange' ? 'v-ionchange' : eventName.toLowerCase();
const toKebabCase = (eventName) => eventName === 'ionChange' ? 'v-ion-change' : eventName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
/**
 * Vue 3.0.6 fixed a bug where events on custom elements
 * were always converted to lower case, so "ionRefresh"
 * became "ionRefresh". We need to account for the old
 * issue as well as the new behavior where "ionRefresh"
 * is converted to "ion-refresh".
 * See https://github.com/vuejs/vue-next/pull/2847
 */
const getHelperFunctions = (needsKebabCase = true) => {
    const conversionFn = (needsKebabCase) ? toKebabCase : toLowerCase;
    return {
        ael: (el, eventName, cb, opts) => el.addEventListener(conversionFn(eventName), cb, opts),
        rel: (el, eventName, cb, opts) => el.removeEventListener(conversionFn(eventName), cb, opts),
        ce: (eventName, opts) => new CustomEvent(conversionFn(eventName), opts)
    };
};
const IonicVue = {
    async install(app, config = {}) {
        if (typeof window !== 'undefined') {
            const { ael, rel, ce } = getHelperFunctions(needsKebabCase(app.version));
            setupConfig(Object.assign(Object.assign({}, config), { _ael: ael, _rel: rel }));
            await applyPolyfills();
            await defineCustomElements(window, {
                exclude: ['ion-tabs'],
                ce,
                ael,
                rel
            });
        }
    }
};

const IonBackButton = defineComponent({
    name: 'IonBackButton',
    setup(_, { attrs, slots }) {
        const ionRouter = inject('navManager');
        const onClick = () => {
            const defaultHref = attrs['default-href'] || attrs['defaultHref'];
            const routerAnimation = attrs['router-animation'] || attrs['routerAnimation'];
            ionRouter.handleNavigateBack(defaultHref, routerAnimation);
        };
        return () => {
            return h('ion-back-button', Object.assign({ onClick }, attrs), slots.default && slots.default());
        };
    }
});

const IonPage = defineComponent({
    name: 'IonPage',
    props: {
        isInOutlet: { type: Boolean, default: false },
        registerIonPage: { type: Function, default: () => { } }
    },
    mounted() {
        this.$props.registerIonPage(this.$refs.ionPage);
    },
    setup(props, { attrs, slots }) {
        const hidePageClass = (props.isInOutlet) ? 'ion-page-invisible' : '';
        return () => {
            return h('div', Object.assign(Object.assign({ ['class']: `ion-page ${hidePageClass}` }, attrs), { ref: 'ionPage' }), slots.default && slots.default());
        };
    }
});

let viewDepthKey = Symbol(0);
const IonRouterOutlet = defineComponent({
    name: 'IonRouterOutlet',
    setup(_, { attrs }) {
        var _a, _b;
        const injectedRoute = inject(routeLocationKey);
        const route = useRoute();
        const depth = inject(viewDepthKey, 0);
        let usingDeprecatedRouteSetup = false;
        // TODO: Remove in Ionic Vue v6.0
        if (attrs.tabs && ((_b = (_a = route.matched[depth]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            console.warn('[@ionic/vue Deprecation]: Your child routes are nested inside of each tab in your routing config. This format will not be supported in Ionic Vue v6.0. Instead, write your child routes as sibling routes. See https://ionicframework.com/docs/vue/navigation#child-routes-within-tabs for more information.');
            usingDeprecatedRouteSetup = true;
        }
        const matchedRouteRef = computed(() => {
            const matchedRoute = route.matched[depth];
            if (matchedRoute && attrs.tabs && route.matched[depth + 1] && usingDeprecatedRouteSetup) {
                return route.matched[route.matched.length - 1];
            }
            return matchedRoute;
        });
        provide(viewDepthKey, depth + 1);
        provide(matchedRouteKey, matchedRouteRef);
        const ionRouterOutlet = ref();
        const id = generateId('ion-router-outlet');
        // TODO types
        const ionRouter = inject('navManager');
        const viewStacks = inject('viewStacks');
        const components = shallowRef([]);
        let skipTransition = false;
        // The base url for this router outlet
        let parentOutletPath;
        /**
         * We need to watch the route object
         * to listen for navigation changes.
         * Previously we had watched matchedRouteRef,
         * but if you had a /page/:id route, going from
         * page/1 to page/2 would not cause this callback
         * to fire since the matchedRouteRef was the same.
         */
        watch([route, matchedRouteRef], ([currentRoute, currentMatchedRouteRef], [_, previousMatchedRouteRef]) => {
            /**
             * If the matched route ref has changed,
             * then we need to set up a new view item.
             * If the matched route ref has not changed,
             * it is possible that this is a parameterized URL
             * change such as /page/1 to /page/2. In that case,
             * we can assume that the `route` object has changed,
             * but we should only set up a new view item in this outlet
             * if that last matched view item matches our current matched
             * view item otherwise if we had this in a nested outlet the
             * parent outlet would re-render as well as the child page.
             */
            if (currentMatchedRouteRef !== previousMatchedRouteRef ||
                currentRoute.matched[currentRoute.matched.length - 1] === currentMatchedRouteRef) {
                setupViewItem(matchedRouteRef);
            }
        });
        const canStart = () => {
            const config = getConfig();
            const swipeEnabled = config && config.get('swipeBackEnabled', ionRouterOutlet.value.mode === 'ios');
            if (!swipeEnabled)
                return false;
            const stack = viewStacks.getViewStack(id);
            if (!stack || stack.length <= 1)
                return false;
            /**
             * We only want to outlet of the entering view
             * to respond to this gesture, so check
             * to make sure the view is in the outlet we want.
             */
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
            return !!enteringViewItem;
        };
        const onStart = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerAnimation } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
            const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id, usingDeprecatedRouteSetup);
            if (leavingViewItem) {
                let animationBuilder = routerAnimation;
                const enteringEl = enteringViewItem.ionPageElement;
                const leavingEl = leavingViewItem.ionPageElement;
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, 'back', ionRouter.canGoBack(2), true, animationBuilder);
            }
            return Promise.resolve();
        };
        const onEnd = (shouldContinue) => {
            if (shouldContinue) {
                skipTransition = true;
                /**
                 * Use the same logic as clicking
                 * ion-back-button to determine where
                 * to go back to.
                 */
                ionRouter.handleNavigateBack();
            }
            else {
                /**
                 * In the event that the swipe
                 * gesture was aborted, we should
                 * re-hide the page that was going to enter.
                 */
                const routeInfo = ionRouter.getCurrentRouteInfo();
                const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
                enteringViewItem.ionPageElement.setAttribute('aria-hidden', 'true');
                enteringViewItem.ionPageElement.classList.add('ion-page-hidden');
            }
        };
        watch(ionRouterOutlet, () => {
            ionRouterOutlet.value.swipeHandler = {
                canStart,
                onStart,
                onEnd
            };
        });
        const transition = (enteringEl, leavingEl, direction, // TODO types
        showGoBack, progressAnimation, animationBuilder) => {
            return new Promise(resolve => {
                if (skipTransition) {
                    skipTransition = false;
                    return resolve(false);
                }
                if (enteringEl === leavingEl) {
                    return resolve(false);
                }
                requestAnimationFrame(() => {
                    requestAnimationFrame(async () => {
                        enteringEl.classList.add('ion-page-invisible');
                        const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {
                            deepWait: true,
                            duration: direction === undefined || direction === 'root' || direction === 'none' ? 0 : undefined,
                            direction,
                            showGoBack,
                            progressAnimation,
                            animationBuilder
                        });
                        return resolve(result);
                    });
                });
            });
        };
        const handlePageTransition = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerDirection, routerAction, routerAnimation, prevRouteLastPathname } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id, usingDeprecatedRouteSetup);
            let leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id, true, usingDeprecatedRouteSetup);
            const enteringEl = enteringViewItem.ionPageElement;
            if (enteringViewItem === leavingViewItem)
                return;
            if (!leavingViewItem && prevRouteLastPathname) {
                leavingViewItem = viewStacks.findViewItemByPathname(prevRouteLastPathname, id, usingDeprecatedRouteSetup);
            }
            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);
            if (leavingViewItem && enteringViewItem !== leavingViewItem) {
                let animationBuilder = routerAnimation;
                const leavingEl = leavingViewItem.ionPageElement;
                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    routerDirection === 'back' &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);
                leavingEl.classList.add('ion-page-hidden');
                leavingEl.setAttribute('aria-hidden', 'true');
                if (routerAction === 'replace') {
                    leavingViewItem.mount = false;
                    leavingViewItem.ionPageElement = undefined;
                    leavingViewItem.ionRoute = false;
                }
                else if (!(routerAction === 'push' && routerDirection === 'forward')) {
                    const shouldLeavingViewBeRemoved = routerDirection !== 'none' && leavingViewItem && (enteringViewItem !== leavingViewItem);
                    if (shouldLeavingViewBeRemoved) {
                        leavingViewItem.mount = false;
                        leavingViewItem.ionPageElement = undefined;
                        leavingViewItem.ionRoute = false;
                    }
                }
                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);
            }
            else {
                /**
                 * If there is no leaving element, just show
                 * the entering element. Wrap it in an raf
                 * in case ion-content's fullscreen callback
                 * is running. Otherwise we'd have a flicker.
                 */
                requestAnimationFrame(() => enteringEl.classList.remove('ion-page-invisible'));
            }
            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);
            components.value = viewStacks.getChildrenToRender(id);
        };
        const setupViewItem = (matchedRouteRef) => {
            const firstMatchedRoute = route.matched[0];
            if (!parentOutletPath) {
                parentOutletPath = firstMatchedRoute.path;
            }
            /**
             * If no matched route, do not do anything in this outlet.
             * If there is a match, but it the first matched path
             * is not the root path for this outlet, then this view
             * change needs to be rendered in a different outlet.
             * We also add an exception for when the matchedRouteRef is
             * equal to the first matched route (i.e. the base router outlet).
             * This logic is mainly to help nested outlets/multi-tab
             * setups work better.
             */
            if (!matchedRouteRef.value ||
                (matchedRouteRef.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath)) {
                return;
            }
            const currentRoute = ionRouter.getCurrentRouteInfo();
            let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id, usingDeprecatedRouteSetup);
            if (!enteringViewItem) {
                enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef.value.components.default, matchedRouteRef.value, currentRoute);
                viewStacks.add(enteringViewItem);
            }
            if (!enteringViewItem.mount) {
                enteringViewItem.mount = true;
                enteringViewItem.registerCallback = () => {
                    handlePageTransition();
                    enteringViewItem.registerCallback = undefined;
                };
            }
            else {
                handlePageTransition();
            }
            components.value = viewStacks.getChildrenToRender(id);
        };
        if (matchedRouteRef.value) {
            setupViewItem(matchedRouteRef);
        }
        /**
         * Remove stack data for this outlet
         * when outlet is destroyed otherwise
         * we will see cached view data.
         */
        onUnmounted(() => viewStacks.clear(id));
        // TODO types
        const registerIonPage = (viewItem, ionPageEl) => {
            const oldIonPageEl = viewItem.ionPageElement;
            viewStacks.registerIonPage(viewItem, ionPageEl);
            /**
             * If there is a registerCallback,
             * then this component is being registered
             * as a result of a navigation change.
             */
            if (viewItem.registerCallback) {
                viewItem.registerCallback();
                /**
                 * If there is no registerCallback, then
                 * this component is likely being re-registered
                 * as a result of a hot module replacement.
                 * We need to see if the oldIonPageEl has
                 * .ion-page-invisible. If it does not then we
                 * need to remove it from the new ionPageEl otherwise
                 * the page will be hidden when it is replaced.
                 */
            }
            else if (oldIonPageEl && !oldIonPageEl.classList.contains('ion-page-invisible')) {
                ionPageEl.classList.remove('ion-page-invisible');
            }
        };
        return {
            id,
            components,
            injectedRoute,
            ionRouterOutlet,
            registerIonPage
        };
    },
    render() {
        const { components, registerIonPage, injectedRoute } = this;
        return h('ion-router-outlet', { ref: 'ionRouterOutlet' }, 
        // TODO types
        components && components.map((c) => {
            var _a, _b;
            let props = {
                ref: c.vueComponentRef,
                key: c.pathname,
                isInOutlet: true,
                registerIonPage: (ionPageEl) => registerIonPage(c, ionPageEl)
            };
            /**
             * IonRouterOutlet does not support named outlets.
             */
            const routePropsOption = (_b = (_a = c.matchedRoute) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.default;
            /**
             * Since IonRouterOutlet renders multiple components,
             * each render will cause all props functions to be
             * called again. As a result, we need to cache the function
             * result and provide it on each render so that the props
             * are not lost when navigating from and back to a page.
             * When a component is destroyed and re-created, the
             * function is called again.
             */
            const getPropsFunctionResult = () => {
                var _a;
                const cachedPropsResult = (_a = c.vueComponentData) === null || _a === void 0 ? void 0 : _a.propsFunctionResult;
                if (cachedPropsResult) {
                    return cachedPropsResult;
                }
                else {
                    const propsFunctionResult = routePropsOption(injectedRoute);
                    c.vueComponentData = Object.assign(Object.assign({}, c.vueComponentData), { propsFunctionResult });
                    return propsFunctionResult;
                }
            };
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? c.params
                    : typeof routePropsOption === 'function'
                        ? getPropsFunctionResult()
                        : routePropsOption
                : null;
            props = Object.assign(Object.assign({}, props), routeProps);
            return h(c.vueComponent, props);
        }));
    }
});

const IonTabButton = defineComponent({
    name: 'IonTabButton',
    props: {
        _getTabState: { type: Function, default: () => { return {}; } },
        disabled: Boolean,
        download: String,
        href: String,
        rel: String,
        layout: String,
        selected: Boolean,
        tab: String,
        target: String
    },
    setup(props, { slots }) {
        const ionRouter = inject('navManager');
        const onClick = (ev) => {
            if (ev.cancelable) {
                ev.preventDefault();
            }
            /**
             * Keeping track of the originalHref
             * (i.e. /tabs/tab1) lets us redirect
             * users back to a child page using currentHref
             * (i.e. /tabs/tab1/child).
             */
            const { tab, href, _getTabState } = props;
            const tabState = _getTabState();
            const tappedTab = tabState.tabs[tab] || {};
            const originalHref = tappedTab.originalHref || href;
            const currentHref = tappedTab.currentHref || href;
            const prevActiveTab = tabState.activeTab;
            /**
             * If we are still on the same
             * tab as before, but the base href
             * does not equal the current href,
             * then we must be on a child page and
             * should direct users back to the root
             * of the tab.
             */
            if (prevActiveTab === tab) {
                if (originalHref !== currentHref) {
                    ionRouter.resetTab(tab, originalHref);
                }
            }
            else {
                ionRouter.changeTab(tab, currentHref);
            }
        };
        return () => {
            return h('ion-tab-button', Object.assign({ onClick }, props), slots.default && slots.default());
        };
    }
});

const WILL_CHANGE = 'ionTabsWillChange';
const DID_CHANGE = 'ionTabsDidChange';
const IonTabs = defineComponent({
    name: 'IonTabs',
    emits: [WILL_CHANGE, DID_CHANGE],
    data() {
        return { didWarn: false };
    },
    render() {
        var _a;
        const { $slots: slots, $emit, $data } = this;
        const slottedContent = slots.default && slots.default();
        let userProvidedRouterOutlet;
        if (slottedContent && slottedContent.length > 0) {
            /**
             * If developer passed in their own ion-router-outlet
             * instance, then we should not init a default one
             */
            userProvidedRouterOutlet = slottedContent.find((child) => child.type && child.type.name === 'IonRouterOutlet');
        }
        let childrenToRender = [
            h('div', {
                class: 'tabs-inner',
                style: {
                    'position': 'relative',
                    'flex': '1',
                    'contain': 'layout size style'
                }
            }, (userProvidedRouterOutlet) ? userProvidedRouterOutlet : [h(IonRouterOutlet, { tabs: true })])
        ];
        if (userProvidedRouterOutlet && !$data.didWarn) {
            console.warn(`[@ionic/vue Deprecation] Starting in Ionic Vue v6.0, developers must add an 'ion-router-outlet' instance inside of 'ion-tabs'.

      Before:

      <ion-tabs>
        <ion-tab-bar slot="bottom">
          ...
        </ion-tab-bar>
      </ion-tabs>

      After:

      <ion-tabs>
        <ion-router-outlet></ion-router-outlet>
        <ion-tab-bar slot="bottom">
          ...
        </ion-tab-bar>
      </ion-tabs>

      Be sure to import 'IonRouterOutlet' from '@ionic/vue' and provide that import to your Vue component. See https://ionicframework.com/docs/vue/navigation#working-with-tabs for more information.
      `);
            $data.didWarn = true;
        }
        /**
         * If ion-tab-bar has slot="top" it needs to be
         * rendered before `.tabs-inner` otherwise it will
         * not show above the tab content.
         */
        if (slottedContent && slottedContent.length > 0) {
            /**
             * Render all content except for router outlet
             * since that needs to be inside of `.tabs-inner`.
             */
            const filteredContent = slottedContent.filter((child) => (!child.type ||
                (child.type && child.type.name !== 'IonRouterOutlet')));
            const slottedTabBar = filteredContent.find((child) => child.type && child.type.name === 'IonTabBar');
            const hasTopSlotTabBar = slottedTabBar && ((_a = slottedTabBar.props) === null || _a === void 0 ? void 0 : _a.slot) === 'top';
            if (slottedTabBar) {
                if (!slottedTabBar.props) {
                    slottedTabBar.props = {};
                }
                /**
                 * ionTabsWillChange and ionTabsDidChange are
                 * fired from `ion-tabs`, so we need to pass these down
                 * as props so they can fire when the active tab changes.
                 * TODO: We may want to move logic from the tab bar into here
                 * so we do not have code split across two components.
                 */
                slottedTabBar.props._tabsWillChange = (tab) => $emit(WILL_CHANGE, { tab });
                slottedTabBar.props._tabsDidChange = (tab) => $emit(DID_CHANGE, { tab });
            }
            if (hasTopSlotTabBar) {
                childrenToRender = [
                    ...filteredContent,
                    ...childrenToRender
                ];
            }
            else {
                childrenToRender = [
                    ...childrenToRender,
                    ...filteredContent
                ];
            }
        }
        return h('ion-tabs', {
            style: {
                'display': 'flex',
                'position': 'absolute',
                'top': '0',
                'left': '0',
                'right': '0',
                'bottom': '0',
                'flex-direction': 'column',
                'width': '100%',
                'height': '100%',
                'contain': 'layout size style',
                'z-index': '0'
            }
        }, childrenToRender);
    }
});

const isTabButton = (child) => { var _a; return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === 'IonTabButton'; };
const getTabs = (nodes) => {
    let tabs = [];
    nodes.forEach((node) => {
        if (isTabButton(node)) {
            tabs.push(node);
        }
        else if (Array.isArray(node.children) && node.children.length > 1) {
            const childTabs = getTabs(node.children);
            tabs = [...tabs, ...childTabs];
        }
    });
    return tabs;
};
const IonTabBar = defineComponent({
    name: 'IonTabBar',
    props: {
        _tabsWillChange: { type: Function, default: () => { } },
        _tabsDidChange: { type: Function, default: () => { } }
    },
    data() {
        return {
            tabState: {
                activeTab: undefined,
                tabs: {}
            },
            tabVnodes: []
        };
    },
    updated() {
        this.setupTabState(inject('navManager'));
    },
    methods: {
        setupTabState(ionRouter) {
            /**
             * For each tab, we need to keep track of its
             * base href as well as any child page that
             * is active in its stack so that when we go back
             * to a tab from another tab, we can correctly
             * show any child pages if necessary.
             */
            const tabState = this.$data.tabState;
            const currentInstance = getCurrentInstance();
            const tabs = this.$data.tabVnodes = getTabs((currentInstance.subTree.children || []));
            tabs.forEach(child => {
                tabState.tabs[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href,
                    ref: child
                };
                /**
                 * Passing this prop to each tab button
                 * lets it be aware of the state that
                 * ion-tab-bar is managing for it.
                 */
                child.component.props._getTabState = () => tabState;
            });
            this.checkActiveTab(ionRouter);
        },
        checkActiveTab(ionRouter) {
            const currentRoute = ionRouter.getCurrentRouteInfo();
            const childNodes = this.$data.tabVnodes;
            const { tabs, activeTab: prevActiveTab } = this.$data.tabState;
            const tabState = this.$data.tabState;
            const tabKeys = Object.keys(tabs);
            const activeTab = tabKeys
                .find(key => {
                const href = tabs[key].originalHref;
                return currentRoute.pathname.startsWith(href);
            });
            /**
             * For each tab, check to see if the
             * base href has changed. If so, update
             * it in the tabs state.
             */
            childNodes.forEach((child) => {
                const tab = tabs[child.props.tab];
                if (!tab || (tab.originalHref !== child.props.href)) {
                    tabs[child.props.tab] = {
                        originalHref: child.props.href,
                        currentHref: child.props.href,
                        ref: child
                    };
                }
            });
            if (activeTab && prevActiveTab) {
                const prevHref = this.$data.tabState.tabs[prevActiveTab].currentHref;
                /**
                 * If the tabs change or the url changes,
                 * update the currentHref for the active tab.
                 * Ex: url changes from /tabs/tab1 --> /tabs/tab1/child
                 * If we went to tab2 then back to tab1, we should
                 * land on /tabs/tab1/child instead of /tabs/tab1.
                 */
                if (activeTab !== prevActiveTab || (prevHref !== currentRoute.pathname)) {
                    tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), { currentHref: currentRoute.pathname + (currentRoute.search || '') });
                }
                /**
                 * If navigating back and the tabs change,
                 * set the previous tab back to its original href.
                 */
                if (currentRoute.routerAction === 'pop' && (activeTab !== prevActiveTab)) {
                    tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), { currentHref: tabs[prevActiveTab].originalHref });
                }
            }
            const activeChild = childNodes.find((child) => { var _a; return isTabButton(child) && ((_a = child.props) === null || _a === void 0 ? void 0 : _a.tab) === activeTab; });
            const tabBar = this.$refs.ionTabBar;
            const tabDidChange = activeTab !== prevActiveTab;
            if (tabBar) {
                if (activeChild) {
                    tabDidChange && this.$props._tabsWillChange(activeTab);
                    ionRouter.handleSetCurrentTab(activeTab);
                    tabBar.selectedTab = tabState.activeTab = activeTab;
                    tabDidChange && this.$props._tabsDidChange(activeTab);
                    /**
                     * When going to a tab that does
                     * not have an associated ion-tab-button
                     * we need to remove the selected state from
                    * the old tab.
                     */
                }
                else {
                    tabBar.selectedTab = tabState.activeTab = '';
                }
            }
        }
    },
    mounted() {
        const ionRouter = inject('navManager');
        this.setupTabState(ionRouter);
        ionRouter.registerHistoryChangeListener(() => this.checkActiveTab(ionRouter));
    },
    setup(_, { slots }) {
        return () => {
            return h('ion-tab-bar', { ref: 'ionTabBar' }, slots.default && slots.default());
        };
    }
});

const userComponents = shallowRef([]);
const IonApp = defineComponent({
    name: 'IonApp',
    setup(_, { attrs, slots }) {
        return () => {
            return h('ion-app', Object.assign({}, attrs), [slots.default && slots.default(), ...userComponents.value]);
        };
    }
});
/**
 * When rendering user components inside of
 * ion-modal, or ion-popover the component
 * needs to be created inside of the current application
 * context otherwise libraries such as vue-i18n or vuex
 * will not work properly.
 *
 * `userComponents` renders teleported components as children
 * of `ion-app` within the current application context.
 */
const addTeleportedUserComponent = (component) => {
    userComponents.value = [
        ...userComponents.value,
        component
    ];
};
const removeTeleportedUserComponent = (component) => {
    userComponents.value = userComponents.value.filter(cmp => cmp !== component);
};

const VueDelegate = (addFn = addTeleportedUserComponent, removeFn = removeTeleportedUserComponent) => {
    let Component;
    const attachViewToDom = (parentElement, component, componentProps = {}, classes) => {
        /**
         * Ionic Framework passes in modal and popover element
         * refs as props, but if these are not defined
         * on the Vue component instance as props, Vue will
         * warn the user.
         */
        delete componentProps['modal'];
        delete componentProps['popover'];
        const div = document.createElement('div');
        classes && div.classList.add(...classes);
        parentElement.appendChild(div);
        Component = h(Teleport, { to: div }, h(component, Object.assign({}, componentProps)));
        addFn(Component);
        return div;
    };
    const removeViewFromDom = () => {
        Component && removeFn(Component);
        return Promise.resolve();
    };
    return { attachViewToDom, removeViewFromDom };
};

const IonNav = defineComponent({
    name: 'IonNav',
    setup() {
        const views = shallowRef([]);
        /**
         * Allows us to create the component
         * within the Vue application context.
         */
        const addView = (component) => views.value = [...views.value, component];
        const removeView = (component) => views.value = views.value.filter(cmp => cmp !== component);
        const delegate = VueDelegate(addView, removeView);
        return () => {
            return h('ion-nav', { delegate }, views.value);
        };
    }
});

const IonIcon = defineComponent({
    name: 'IonIcon',
    props: {
        ariaLabel: String,
        color: String,
        flipRtl: Boolean,
        icon: String,
        ios: String,
        lazy: String,
        md: String,
        mode: String,
        name: String,
        size: String,
        src: String
    },
    setup(props, { slots }) {
        return () => {
            var _a, _b;
            const { icon, ios, md } = props;
            let iconToUse;
            if (ios || md) {
                if (isPlatform('ios')) {
                    iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
                }
                else {
                    iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
                }
            }
            else {
                iconToUse = icon;
            }
            return h('ion-icon', Object.assign(Object.assign({}, props), { icon: iconToUse }), slots);
        };
    }
});

/**
 * Make sure we only
 * warn user about each
 * event at most once.
 */
let willPresentWarn = false;
let didPresentWarn = false;
let willDismissWarn = false;
let didDismissWarn = false;
const checkForDeprecatedListeners = (instance) => {
    const props = instance.vnode.props;
    if (!willPresentWarn && props.onOnWillPresent !== undefined) {
        console.warn('[@ionic/vue Deprecation]: @onWillPresent has been deprecated in favor of @willPresent and will be removed in Ionic Vue v6.0.');
        willPresentWarn = true;
    }
    if (!didPresentWarn && props.onOnDidPresent !== undefined) {
        console.warn('[@ionic/vue Deprecation]: @onDidPresent has been deprecated in favor of @didPresent and will be removed in Ionic Vue v6.0.');
        didPresentWarn = true;
    }
    if (!willDismissWarn && props.onOnWillDismiss !== undefined) {
        console.warn('[@ionic/vue Deprecation]: @onWillDismiss has been deprecated in favor of @willDismiss and will be removed in Ionic Vue v6.0.');
        willDismissWarn = true;
    }
    if (!didDismissWarn && props.onOnDidDismiss !== undefined) {
        console.warn('[@ionic/vue Deprecation]: @onDidDismiss has been deprecated in favor of @didDismiss and will be removed in Ionic Vue v6.0.');
        didDismissWarn = true;
    }
};
const defineOverlayContainer = (name, componentProps = [], controller) => {
    /**
     * Vue 3.0.6 fixed a bug where events on custom elements
     * were always converted to lower case, so "ionRefresh"
     * became "ionrefresh". We need to account for the old
     * issue as well as the new behavior where "ionRefresh"
     * is converted to "ion-refresh".
     * See https://github.com/vuejs/vue-next/pull/2847
     */
    const eventPrefix = name.toLowerCase().split('-').join('');
    const lowerCaseListeners = [
        { componentEv: `${eventPrefix}willpresent`, frameworkEv: 'willPresent', deprecatedEv: 'onWillPresent' },
        { componentEv: `${eventPrefix}didpresent`, frameworkEv: 'didPresent', deprecatedEv: 'onDidPresent' },
        { componentEv: `${eventPrefix}willdismiss`, frameworkEv: 'willDismiss', deprecatedEv: 'onWillDismiss' },
        { componentEv: `${eventPrefix}diddismiss`, frameworkEv: 'didDismiss', deprecatedEv: 'onDidDismiss' },
    ];
    const kebabCaseListeners = [
        { componentEv: `${name}-will-present`, frameworkEv: 'willPresent', deprecatedEv: 'onWillPresent' },
        { componentEv: `${name}-did-present`, frameworkEv: 'didPresent', deprecatedEv: 'onDidPresent' },
        { componentEv: `${name}-will-dismiss`, frameworkEv: 'willDismiss', deprecatedEv: 'onWillDismiss' },
        { componentEv: `${name}-did-dismiss`, frameworkEv: 'didDismiss', deprecatedEv: 'onDidDismiss' },
    ];
    const Container = defineComponent((props, { slots, emit }) => {
        const instance = getCurrentInstance();
        const adjustedEventListeners = needsKebabCase(instance.appContext.app.version) ? kebabCaseListeners : lowerCaseListeners;
        checkForDeprecatedListeners(instance);
        const overlay = ref();
        const onVnodeMounted = async () => {
            const isOpen = props.isOpen;
            isOpen && (await present(props));
        };
        const onVnodeUpdated = async (node, prevNode) => {
            const isOpen = node.props.isOpen;
            const prevIsOpen = prevNode.props.isOpen;
            /**
             * Do not do anything if this prop
             * did not change.
             */
            if (isOpen === prevIsOpen)
                return;
            if (isOpen) {
                await present(props);
            }
            else {
                await dismiss();
            }
        };
        const onVnodeBeforeUnmount = async () => {
            await dismiss();
        };
        const dismiss = async () => {
            if (!overlay.value)
                return;
            await overlay.value;
            overlay.value = overlay.value.dismiss();
            await overlay.value;
            overlay.value = undefined;
        };
        const present = async (props) => {
            var _a;
            /**
             * Do not open another instance
             * if one is already opened.
             */
            if (overlay.value) {
                await overlay.value;
            }
            if ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present) {
                await overlay.value.present();
                return;
            }
            /**
             * When supporting both the "on" prefixed and non-"on" prefixed
             * events, there seems to be an issue where the handlers are
             * getting passed as props. This should be resolved when we drop
             * support for the "on" prefixed listeners.
             */
            const restOfProps = Object.assign({}, props);
            delete restOfProps.onWillPresent;
            delete restOfProps.onDidPresent;
            delete restOfProps.onWillDismiss;
            delete restOfProps.onDidDismiss;
            const component = slots.default && slots.default()[0];
            overlay.value = controller.create(Object.assign(Object.assign({}, restOfProps), { component }));
            overlay.value = await overlay.value;
            adjustedEventListeners.forEach(eventListener => {
                overlay.value.addEventListener(eventListener.componentEv, () => {
                    emit(eventListener.frameworkEv);
                    emit(eventListener.deprecatedEv);
                });
            });
            await overlay.value.present();
        };
        return () => {
            return h('div', {
                style: { display: 'none' },
                onVnodeMounted,
                onVnodeUpdated,
                onVnodeBeforeUnmount,
                isOpen: props.isOpen
            });
        };
    });
    Container.displayName = name;
    Container.props = [...componentProps, 'isOpen'];
    Container.emits = [
        'willPresent', 'didPresent', 'willDismiss', 'didDismiss',
        'onWillPresent', 'onDidPresent', 'onWillDismiss', 'onDidDismiss'
    ];
    return Container;
};

/* auto-generated vue overlay proxies */
const IonActionSheet = /*@__PURE__*/ defineOverlayContainer('ion-action-sheet', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent'], actionSheetController);
const IonAlert = /*@__PURE__*/ defineOverlayContainer('ion-alert', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'inputs', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent'], alertController);
const IonLoading = /*@__PURE__*/ defineOverlayContainer('ion-loading', ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent'], loadingController);
const IonModal = /*@__PURE__*/ defineOverlayContainer('ion-modal', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'swipeToClose'], modalController);
const IonPicker = /*@__PURE__*/ defineOverlayContainer('ion-picker', ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop'], pickerController);
const IonPopover = /*@__PURE__*/ defineOverlayContainer('ion-popover', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'event', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent'], popoverController);
const IonToast = /*@__PURE__*/ defineOverlayContainer('ion-toast', ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'position', 'translucent'], toastController);

const useBackButton = (priority, handler) => {
    const callback = (ev) => ev.detail.register(priority, handler);
    const unregister = () => document.removeEventListener('ionBackButton', callback);
    document.addEventListener('ionBackButton', callback);
    return { unregister };
};
const useIonRouter = () => {
    const { canGoBack } = inject('navManager');
    return {
        canGoBack
    };
};
const useKeyboard = () => {
    let isOpen = ref(false);
    let keyboardHeight = ref(0);
    const showCallback = (ev) => {
        isOpen.value = true;
        keyboardHeight.value = ev.detail.keyboardHeight;
    };
    const hideCallback = () => {
        isOpen.value = false;
        keyboardHeight.value = 0;
    };
    const unregister = () => {
        if (typeof window !== 'undefined') {
            window.removeEventListener('ionKeyboardDidShow', showCallback);
            window.removeEventListener('ionKeyboardDidHide', hideCallback);
        }
    };
    if (typeof window !== 'undefined') {
        window.addEventListener('ionKeyboardDidShow', showCallback);
        window.addEventListener('ionKeyboardDidHide', hideCallback);
    }
    return {
        isOpen,
        keyboardHeight,
        unregister
    };
};
/**
 * Creates an returns a function that
 * can be used to provide a lifecycle hook.
 */
const injectHook = (lifecycleType, hook, component) => {
    if (component) {
        // Add to public instance so it is accessible to IonRouterOutlet
        const target = component;
        const hooks = target.proxy[lifecycleType] || (target.proxy[lifecycleType] = []);
        const wrappedHook = (...args) => {
            if (target.isUnmounted) {
                return;
            }
            return args ? hook(...args) : hook();
        };
        hooks.push(wrappedHook);
        return wrappedHook;
    }
    else {
        console.warn('[@ionic/vue]: Ionic Lifecycle Hooks can only be used during execution of setup().');
    }
};
const createHook = (lifecycle) => {
    return (hook, target = getCurrentInstance()) => injectHook(lifecycle, hook, target);
};
const onIonViewWillEnter = createHook(LifecycleHooks.WillEnter);
const onIonViewDidEnter = createHook(LifecycleHooks.DidEnter);
const onIonViewWillLeave = createHook(LifecycleHooks.WillLeave);
const onIonViewDidLeave = createHook(LifecycleHooks.DidLeave);

const oldModalCreate = modalController.create.bind(modalController);
modalController.create = (options) => {
    return oldModalCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};
const oldPopoverCreate = popoverController.create.bind(popoverController);
popoverController.create = (options) => {
    return oldPopoverCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};

// Icons that are used by internal components
addIcons({
    'arrow-back-sharp': arrowBackSharp,
    'caret-back-sharp': caretBackSharp,
    'chevron-back': chevronBack,
    'chevron-forward': chevronForward,
    'close': close,
    'close-circle': closeCircle,
    'close-sharp': closeSharp,
    'menu-outline': menuOutline,
    'menu-sharp': menuSharp,
    'reorder-two-sharp': reorderTwoSharp,
    'reorder-three-outline': reorderThreeOutline,
    'search-outline': searchOutline,
    'search-sharp': searchSharp,
});

export { IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicVue, onIonViewDidEnter, onIonViewDidLeave, onIonViewWillEnter, onIonViewWillLeave, useBackButton, useIonRouter, useKeyboard };
//# sourceMappingURL=index.esm.js.map
